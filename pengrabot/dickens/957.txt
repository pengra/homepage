I wanted to do something in WebGL (which is much simpler than I thought) and I ended up writing this.  I made an effort to make this article readable on any browser, but it's much better with WebGL enabled, so I strongly recommend turning it on. Knowing how this works is not required to enjoy the animations, so feel free to skip the math sections if they do not interest you (or if you already know all this). I strongly encourage you to enable JavaScript for this post, but if you'd rather not, you can keep on reading — I've added some YouTube embeds and images for this case. f(z) = 0 Iteration steps shown on the complex plane. We set the color value (the V in HSV) based on the number of steps taken. This makes good starting points lighter and darkens those that converge slower. (z-1)·(z-2)·(z-3) (z-1)·(z-2)·(z-3) Choosing HSV in the fragment shader Generating these graphs is somewhat computationally intensive. Every pixel needs to perform a separate Newton iteration, the input functions can be complicated and they operate on complex numbers — pairs of floats, rather than floats themselves. Even something as simple as multiplication of two complex numbers takes a few operations. GLSL code for complex multiplication Generating them in real-time, with a high resolution and frame rate in a high level language on the CPU is a nonstarter. Fortunately this problem lends itself really well to parallelization. And with today's powerful GPUs and increasing WebGL support, we can run the iteration in parallel in a browser. Breaking it down into steps, the process goes like this. Selected differentiation rules Generated GLSL. Uniforms declared in the fragment shader. Every frame, we update the uniform values (without recompiling the shaders). Setting uniform values. Detecting touch force changes. Householder's method. Different WebGL implementations may produce slightly different results and sometimes glitches might show up. Also, there might be some bugs in the shader code, especially the more exotic complex functions — web GLSL isn't exactly easy to test. You can write your own equations. One way to get started is by playing with existing functions — change the constants, add things, multiply by things, wrap things with functions, change functions to other functions, and so on. Let me know if you find anything interesting!