When you subscribe to Nuts & Volts — Print Edition, unlike other magazines, you also get full access to our Digital Edition at no extra charge. So, YOU can choose how you want to read your issues! Some readers prefer a paper copy they can hold in their hands or keep on their bench. But if that’s not you, then get the Online Only Edition and save a few trees and some cash. Just review the options below and click SUBSCRIBE to make a selection and place your order. Easy! Above Image Credit: Penn State Lehigh Valley web site. Programmers today are faced with an embarrassment of riches. Software tools are rich and plentiful, and hardware is powerful and cheap. One simple way to measure the ever increasing complexity and sophistication of software tools is to see what it takes to produce a “Hello, world!” program. In the early days of C and Unix™, it only took a few lines of source code. Now, using a Windows C/C++ compiler or other GUI programming tool, even producing a simple “hello world” program involves hundreds of lines of support code that the application programmer rarely sees. The programming environments can be large because the machines available today rise in power as they fall in price. Tools are getting easier to use and debuggers are getting more sophisticated. It’s a good time to be a programmer, but sometimes we’re blinded by the power and elegance of our software tools and hardware platforms. Sometimes it’s worthwhile to step back and look at the world in terms of first principles. Physicists (at least the good ones) view the world from first principles. In mathematics, first principles are called axioms. It’s refreshing to get away from the everyday routine of cranking out programs and to think about computers in terms of axioms. What do axioms have to do with writing computer programs? Try to answer this simple question: what is a computation? The world as we know it changed in 1936. The same year the Hoover Dam began generating electricity and Shirley Temple was the top box office draw, a 24-year-old Englishman named Alan Turing completed a paper called “On Computable Numbers” with an application to the Entsheidungsproblem. Entsheidungsproblem is the German expression for the question of decidability. In his somewhat obscure paper, Turing described an abstract universal computing machine, now called a Turing Machine. As it turns out, there is no greater machine, theoretical or real, that equals the capability of a Turing Machine. The Turing Machine is at the bedrock of modern computer science. Turing’s abstract machine, as he insisted from the start, could actually be built. Unfortunately, 1936 was also the year that 4,000 Nazi troops quietly slipped into the Rhineland and occupied the de-militarized zone dictated by the Treaty of Versailles, foreshadowing the beginning of World War II. In 1940, with England at war, and with German U-boats ruthlessly destroying convoy ships, Turing (and other talented mathematicians) were conscripted by the British high command to help crack German military codes. Luckily, a secret German cipher machine called “Enigma” was captured from a sinking U-boat. With the added bonus of the captured Enigma, Turing cracked the supposedly unbreakable Enigma code and had a significant hand in the Allies winning the war in the North Atlantic. The unfortunate effect of the war is that it halted the development and materialization of a Universal Turing Machine. After World War II, a race of sorts between England and the United States to build the first digital computer was off and running. England was building the ACE (Automatic Computing Engine), and the United States was building the ENIAC (Electronic Numerical Integrator And Calculator). Turing was on the periphery of the ACE project and not at the heart of the hardware design, so he turned his thoughts to instruction tables, or what we now call software. FIGURE 1. The read/write head, (sometimes called the control head), can read, write, or erase a symbol on the tape segment it is currently under, but only one segment at a time. Believe it or not, this simplest of simple computers is capable of doing anything the most powerful supercomputer can do. FIGURE 2. FIGURE 3. FIGURE 4. FIGURE 5. So we’ve shown that our Turing Machine that changes the symbol a to the symbol b actually works. So what’s the big deal? Well, the big deal is that the algorithm to convert one character to another is truly a computation and, since it runs correctly on a Turing Machine, it should run on any conceivable computer in the universe! That’s how deep and profound a Turing Machine really is. What about adding two numbers together? We know intuitively that it’s indeed a computation, but how do you prove it? See if it runs on a Turing Machine! One way to express numbers on a tape is to use unary format. In unary format, the number two is expressed as 0110. Three ones are used to represent the number three, and zeros are used to separate the numbers. The number five is unary format is 0111110. We want to see if two plus two is a computation, so the tape will look like B0110110B (don’t forget that the tape is full of blanks, so we have blank symbols reaching into infinity on both ends of the tape). How can we create a Turing Machine to add these two unary numbers? Look at the tape for a while. The result we want is four, or 011110. If we can shift the rightmost ones to the left one place, we’ll have the desired result. What we need is a form of a shift register. FIGURE 6. The Turing Machine Simulator consists of three parts: the input tape file, the transition functions file, and the tms.exe simulator. The input tape file is an ASCII text file that contains the tape characters. The transition function file uses a format similar to the classical Turing Machine form. Comments are also accommodated by placing a C at the beginning of a line. With the somewhat cryptic nature of the classical Turing Machine notation, the liberal use of comments is usually necessary (if you want to remember what you did!). A rudimentary parser reads the transitions from the source file and loads the transitions into an array of structures. What we’ve really built is an interpreter. The transition function file is the program source code, the input tape file is the data, and the tms.exe program is the interpreter. The process of reading a source code file, breaking the source into individual symbols or tokens, then storing the tokens in a data structure is called parsing. Our parser is in the function ReadTuringMachine( ). To keep the code length short, ReadTuringMachine( ) contains little error checking. This means that the transition function file needs to be reasonably correct, since ReadTuringMachine( ) does not detect syntax errors. FIGURE 7. FIGURE 8. Hopefully, this article has turned you on to Turing Machines. The simple Turing Machine program designed here is just a starting point. There are multi-tape Turing Machines, Universal Turing Machines, and many other variations. Adapting the TMS program to read multiple tapes would be an interesting project. Thinking in terms of Turing Machines can be difficult and laborious at times, but the reward is the gained insight into the fundamental nature of computation. It’s fun to write Turing Machines and watch them chug away on the simulator. Try designing a Turing Machine to copy strings or to do other fundamental arithmetic operations such as subtraction or multiplication. Some machines may be easy to create, and some may be profoundly difficult. Try it and see. Just create an input tape file and a transition function file. I usually put a .dat extension on the input tape files and a .tm extension on the transition function files. There is no naming constraint, so use your own system if you like. Want to learn more? There are plenty of web sites that contain detailed, interesting information about Turing Machines, and plenty of transition functions that you can find to run through the simulator. Remember, out of all of the sciences, computer science is still in its infancy. There are many important discoveries to make and great problems to solve. TMS.zip Turing Machine Simulator Files Turing Machine Simulator Files ESP8266 Webcam - More Logic Analyzer - Garage Sentinal Logic Analyzers - Harvesting Electricity - Garage Door Closer - Build Something! Selected questions from past Q&A columns. Need to brush up on your electronics principles? These multi-part series may be just what you need! Sign Up Now