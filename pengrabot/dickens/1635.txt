Anyone knows if there is a way to do a bulk update?. I'm aware of the update method, but it does not work when you need to update a field with different values. Has anyone faced something like this?, update thousands of objects without using the save method. EDIT: First, thank you all for taking a time to help me with this problem. Now, to precise a little bit the issue, I'll write the affected models here: These are the models affected (the first one is the one that has to be updated): Itemplan has items (products) associated to a plan (budget). So, different budgets have different itemplan instances. The next model, is like the item master (all the products/items live here). And here lies the father-son relationship. So, when I'm creating a itemplan obj, I need to "ask" for his father to the Item model. It has to be and update because the self reference can only exist after the object is created (has an ID). And if you do use a transaction it will consume all RAM on your machine and then just fail. Happens to me on Webfaction machines all the time (shared hosting with very limited RAM). Are you saying it is not recommendable? No, just saying that depending on your hardware it might not be the holy grail and should be used with caution. I'll check this, thank you! Could you suggest an sql query you want to run? I'm aware of the update method, but it does not work when you need to update a field with different values. I don't quite understand what you mean here. Updating a record is just that - changing the value. Can you be a bit more specific? Perhaps an example of what you're trying to accomplish? SomeModel.objects.filter(location='Here').update(location='There') Imagine you have a customer model, with 10000 objects, and for some reason, you have update one field of all of them. That could be done by using the update method. However, if the update consist of a random number you have to apply to every customer, then, you can not use the update method anymore. You will have to iterate over the whole group and use the save method instead. Here is the code I'm using: In conclusion, there is a different value for every object of the model, that is why I can't use the update method. OK, I understand now. No, update will update everything with the same value (unless you want to based the new value on another column in the same table). For random number, you might as well write a script to do it. but it does not work when you need to update a field with different values I'm not sure that even SQL supports that. Huh, of course it does. Unless I am seriously misunderstanding something. UPDATE table SET column = newvalue  [WHERE condition] And the best part is, you get down voted even though you are right. True, but consider CASE WHEN Otherwise you'll have to drop to SQL. I can't use that method because I need to update every object with a different value. Not even with F expressions? It would really help if you could give an exact description of your problem rather than describing it in abstract. Also, pasting the SQL query you ultimately want to run would also help us understand what you need. If that doesn't solve your problem, then can you tell us how you need to calculate the new values for the fields you are changing? Being precise, the field that I need to update is a self reference foreign key. The model has a father-son relationship between his instances, so, basically, the updates set up this relationship. In order to guess who is the father of a instance, I need to "ask" to another instance of a different model, so, the SQL is not so simple. Could I use the F method to query another model? These are the models affected (the first one is the one that has to be updated): Itemplan has items (products) associated to a plan (budget). So, different budgets have different itemplan instances. The next model, is like the item master (all the products/items live here). And here lies the father-son relationship. So, when I'm creating a itemplan obj, I need to "ask" for his father to the Item model. It has to be and update because the self reference can only exist after the object is created (has an ID). So looking at your data, it looks like you have two trees that you are trying to keep in sync, and that's why you need to have a mass update(). Does that crappy ASCII art look correct? I don't quite understand what you mean by the emphasized part. I think it would just be this: If I have misunderstood the issue, please let me know. Thanks for your comment. English is my second languague, that is why I commit the mistake of using father instead of parent :). About, Itemplan.objects.filter(<whatever>).update(item=F('itemplan_father__item')) It won't work because the itemplan_father__item points to an Item kind of object, not to a Itemplan one. I need the Itemplan father/parent, not the Item. English is my second languague, that is why I commit the mistake of using father instead of parent :). No problem, your English is better than half of the native English speakers I interact with daily. What about that? Only thing I can imagine is to write a stored procedure that returns the desired randon value, then use pure SQL in Django to write an update method that uses a call to that stored procedure as the 'newvalue'. But I'm pretty sure that the database internally loops over all rows (how else could this be done anyways? There is no other way) so I don't know if this stunt would even be worth the effort. 49.0k Subscribers 108 Online