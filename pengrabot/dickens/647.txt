The tape head moves along the tape reading and writing symbols as directed by the Turing machine's programming. During operation, the tape head is in a certain state. Every step, it consults the table (the set of transition functions), based on only the state it's in and the symbol underneath the head, to obtain its next choice: either halt (end the operation), or resume by writing a symbol to the current cell, changing its state, and moving to the left or the right. This way, A Turing machine can simulate the fact that a program is made of many lines and thus it depends on what line a program is executing, and it can also simulate the fact that a program can react differently with different data in memory. A Turing machine can thus either halt at some point or run forever. If it halts, the contents of the tape are the output. As shown in the animation above, a Turing machine consists of a tape that is initialized with a string of symbols. The machine has a head that reads and writes symbols as it moves along the tape. When the tape reads any particular symbol, it decides what to do (what to write to the tape at that point and then which direction to move in next) depending on the set of transition functions associated with the machine. A transition function is essentially a specific instruction line in a Turing machine’s program. You can think of the set of transition functions as the complete program that specifies what the Turing machine should do on any valid input it receives. What state I am in right now What symbol I just read What symbol I should write What state I should change to next Which direction I should move in next The order of these inputs can vary depending on which Turing machine simulator you are using to run your machine, but all of this information will be included. A state can be thought of as a subset of rules. For example, if a Turing machine has two states, when the head reads an “A” symbol in state \(1\), the machine might do one thing, and if the head reads an “A” symbol in state \(2\), it can do a different thing. Transition functions are often represented in a table form. The table below describes a simple Turing machine that takes a string of \(1\)’s as input and doubles it. So “11”  becomes “1111” and so forth. In the specification below, there are three states: state 0,1, and 2. Halt is a special state you can use to indicate that your program has concluded. There are 2 symbols: 1 and A. There are three options for which direction to move: left, right, and stay (indicated by *). Here, the symbol “A” is used to indicate a “1” that we have already seen, and when we read a “1” we write an “A”. This is so we don’t double count symbols. Once we’ve changed all of the 1’s to A’s, all of the symbols on the tape will be A’s. Then, change all of the A’s to 1’s and the original string has been doubled. The code below the tape shows the transition functions. The next step to be taken is highlighted with blue, and the previous step is highlighted in orange. (note in the simulation above, left is denoted by a lower-case L, and right is denoted by a lower-case R.) A Turing machine's operation is a sequence \((\langle q'_s, h_s, (t_{s,p})_{p=-\infty}^\infty \rangle)_{s=0}^\infty\), where such that Turing machines can recognize and decide different kinds of problems and languages. Languages describe problems. For example, there is a language of all strings made up entirely of 1's — some members of this language would be "1", "111111", "111111111", etc. One could make a Turing machine to compute these strings. For example, write a program that just makes the Turing machine write a 1 each time it moves to the right and have it so the machine always moves to the right. Recognizability Decidability Finite State Machines universal Turing machine Church-Turing thesis Nondeterministic Turing Machines Problem Loading... Note Loading... Set Loading...