Subscriber portal By using custom functions, I can extend the Split-And-Merge algorithm to parse not only a mathematical expression, but also to parse a customizable scripting language. The “standard” language control flow statements (if, else, while, continue, break and so on) can be added as custom functions, as can other typical scripting language functionality (OS commands, string manipulation, searching for files and so on). I’m going to call my language Customizable Scripting in C#, or CSCS. Why would I want to create yet another scripting language? Because it’s an easy language to customize. Adding a new function or a new control flow statement that takes an arbitrary number of parameters takes just a few lines of code. Moreover, the function names and the control flow statements can be used in any non-English language scenario with just some configuration changes, which I’ll also show in this article. And by seeing how the CSCS language is implemented, you’ll be able to create your own custom scripting language. It’s fairly simple to implement a very basic scripting language, but brutally difficult to implement a five-star language. I’m going to limit the scope of CSCS here so you’ll know what to expect: I’ve made two changes to the Split part of the Split-And-Merge algorithm. (The Merge part remains the same.) The first change is that the result of parsing an expression can be now a number, a string or a tuple of values (each of which can be either a string or a number), rather than just a number. I created the following Parser.Result class to store the result of applying the Split-And-Merge algorithm: The second modification is that now the splitting part is performed not just until a stop-parsing character—) or \n—is found, but until any character in a passed array of stop-parsing characters is found. This is necessary, for example, when parsing the first argument of an If statement, where the separator can be any <, >, or = character. You can take a look at the modified Split-And-Merge algorithm in the accompanying source code download. The class responsible for interpreting the CSCS code is called Interpreter. It’s implemented as a singleton, that is, a class definition where there can be only one instance of the class. In its Init method, the Parser (see the original article mentioned earlier) is initialized with all the functions used by the Interpreter: In the Constants.cs file, the actual names used in CSCS are defined: Any function registered with the Parser must be implemented as a class derived from the ParserFunction class and must override its Evaluate method. The first thing the Interpreter does when starting to work on a script is to simplify the script by removing all white spaces (unless they’re inside of a string), and all comments. Therefore, spaces or new lines can’t be used as operator separators. The operator separator character and the comment string are defined in Constants.cs, as well: Here are some examples of defining a variable in CSCS: Note that there’s no special declaration of an array: just defining a variable with an index will initialize the array if it’s not already initialized, and add empty elements to it, if necessary. In the preceding example, the elements c(0) and c(1) were added, both initialized to empty strings. This eliminates, in my view, the unnecessary step that’s required in most scripting languages of declaring an array first. Only the set variable function must be registered with the Parser: Some examples of getting variables in CSCS are: The If, Else If and Else control flow statements are implemented internally as Parser functions, as well. They are registered by the Parser just like any other function: Only the IF keyword must be registered with the Parser. ELSE_IF and ELSE statements will be processed inside of the IfStatement implementation: It’s explicitly stated that the If condition has the form: argument 1, comparison sign, argument 2: This is where optional AND, OR or NOT statements can be added. The EvalCondition function just compares the tokens according to the comparison sign: Here’s the implementation of a numerical comparison: The string comparison is similar and is available in the accompanying code download, as is the straightforward implementation of the GetNextIfToken function. Note how the “Continue” and “Break” statements are used inside of the while loop. These statements are implemented as functions, as well. Here’s Continue: The implementation of the Break statement is analogous. They’re both registered with the Parser like any other function: You can use the Break function to get out of nested If blocks or to get out of a while loop. The while loop is also implemented and registered with the Parser as a function: Whenever the while keyword is parsed, the Evaluate method of the WhileStatement object is called: In order for CSCS to do more useful things, more flesh needs to be added; that is, more functions must be implemented. Adding a new function to CSCS is straightforward: First implement a class deriving from the ParserFunction class (overriding the Evaluate method) and then register it with the Parser. Here’s the implementation of the Print function: The function prints any number of comma-separated arguments passed to it. The actual reading of the arguments is done in the GetFunctionArgs auxiliary function, which returns all the passed arguments as a list of strings. You can take a look at the function in the accompanying source code. The second and last step is to register the Print function with the Parser in the program initialization part: The Constants.PRINT constant is defined as “print.” Here’s how you can find files, start and kill a process, and print some values in CSCS:  Figure 9 CSCS Functions Note that you can register multiple labels (function names) corresponding to the same function with the Parser. In this way, it’s possible to add any number of other languages. Adding a translation consists of registering another string with the same C# object. The corresponding C# code follows: The AddTranslation method adds a synonym for an already existing function: Thanks to C# support of Unicode, most languages can be added this way. Note that the variable names can be in Unicode, as well. All of the translations are specified in the configuration file. This is how the configuration file looks for Spanish: Here’s an example of the CSCS code in Spanish: Note that the Parser can now process control statements and functions in both English and Spanish. There’s no limit to the number of languages you can add. All of the CSCS elements—control flow statements, variables, arrays, and functions—are implemented by defining a C# class deriving from the ParserFunction base class and overriding its Evaluate method. Then you register an object of this class with the Parser. This approach provides the following advantages: Of course, at this stage the CSCS language is far from complete. Here are some ways to make it more useful: I hope you’ve enjoyed this glimpse of the CSCS language and seeing how you can create your own custom scripting language. Thanks to the following Microsoft technical expert for reviewing this article: James McCaffrey 