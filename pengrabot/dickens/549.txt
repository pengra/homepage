It's useful to start with an overview of the language's history. JavaScript was created in 1995 by Brendan Eich while he was an engineer at Netscape. JavaScript was first released with Netscape 2 early in 1996. It was originally going to be called LiveScript, but it was renamed in an ill-fated marketing decision that attempted to capitalize on the popularity of Sun Microsystem's Java language — despite the two having very little in common. This has been a source of confusion ever since. Because it is more familiar, we will refer to ECMAScript as "JavaScript" from this point on. Let's start off by looking at the building blocks of any language: the types. JavaScript programs manipulate values, and those values all belong to a type. JavaScript's types are: Numbers in JavaScript are "double-precision 64-bit format IEEE 754 values", according to the spec. This has some interesting consequences. There's no such thing as an integer in JavaScript, so you have to be a little careful with your arithmetic if you're used to math in C or Java. Also, watch out for stuff like: In practice, integer values are treated as 32-bit ints, and some implementations even store it that way until they are asked to perform an instruction that's valid on a Number but not on a 32-bit integer. This can be important for bit-wise operations. In older browsers, strings beginning with a "0" are assumed to be in octal (radix 8), but this hasn't been the case since 2013 or so. Unless you're certain of your string format, you can get surprising results on those older browsers: If you want to convert a binary number to an integer, just change the base: If you want to represent a single character, you just use a string consisting of that single character. If you add a string to a number (or other value) everything is converted into a string first. This might trip you up: Adding an empty string to something is a useful way of converting it to a string itself. To avoid type coercion, use the triple-equals operator: Or for caching values (when falsy values are invalid): JavaScript has a ternary operator for conditional expressions: JavaScript objects can be thought of as simple collections of name-value pairs. As such, they are similar to: The fact that this data structure is so widely used is a testament to its versatility. Since everything (bar core types) in JavaScript is an object, any JavaScript program naturally involves a great deal of hash table lookups. It's a good thing they're so fast! The "name" part is a JavaScript string, while the value can be any JavaScript value — including more objects. This allows you to build data structures of arbitrary complexity. There are two basic ways to create an empty object: And: These are semantically equivalent; the second is called object literal syntax and is more convenient. This syntax is also the core of JSON format and should be preferred at all times. Object literal syntax can be used to initialize an object in its entirety: Attribute access can be chained together: And... One way of creating arrays is as follows: A more convenient notation is to use an array literal: Remember — the length of the array is one more than the highest index. If you want to append an item to an array simply do it like this: Along with objects, functions are the core component in understanding JavaScript. The most basic function couldn't be much simpler: You can also pass in more arguments than the function is expecting: JavaScript lets you create anonymous functions. JavaScript allows you to call functions recursively. This is particularly useful for dealing with tree structures, such as those found in the browser DOM. The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging. Note that JavaScript functions are themselves objects — like everything else in JavaScript — and you can add or change properties on them just like we've seen earlier in the Objects section. In classic Object Oriented Programming, objects are collections of data and methods that operate on that data. JavaScript is a prototype-based language that contains no class statement, as you'd find in C++ or Java (this is sometimes confusing for programmers accustomed to languages with a class statement). Instead, JavaScript uses functions as classes. Let's consider a person object with first and last name fields. There are two ways in which the name might be displayed: as "first last" or as "last, first". Using the functions and objects that we've discussed previously, we could display the data like this: This works, but it's pretty ugly. You end up with dozens of functions in your global namespace. What we really need is a way to attach a function to an object. Since functions are objects, this is easy: Our person objects are getting better, but there are still some ugly edges to them. Every time we create a person object we are creating two brand new function objects within it — wouldn't it be better if this code was shared? That's better: we are creating the method functions only once, and assigning references to them inside the constructor. Can we do any better than that? The answer is yes: This is an incredibly powerful tool. JavaScript lets you modify something's prototype at any time in your program, which means you can add extra methods to existing objects at runtime: Our new method even works on string literals! Calling is therefore almost equivalent to This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down, which is always a good thing. This is also a great counter to the lure of global variables. When writing complex code it is often tempting to use global variables to share values between multiple functions — which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together when it makes sense without polluting your global namespace — "local globals" if you like. This technique should be used with caution, but it's a useful ability to have. This leads us to one of the most powerful abstractions that JavaScript has to offer — but also the most potentially confusing. What does this do? Scope objects form a chain called the scope chain, similar to the prototype chain used by JavaScript's object system. Get the latest and greatest from MDN delivered straight to your inbox. If you haven’t previously confirmed a subscription to a Mozilla-related newsletter you may have to do so. Please check your inbox or your spam filter for an email from us. © 2005-2019 Mozilla and individual contributors.