Let’s sum an array: In this case, we passed in an anonymous reducing function, but we can abstract it and give it a name: Map: Filter: Compose: Reduce lets us abstract that process to work on any number of functions, so you could easily define a function that would represent: Pipe: See the problem? The first step is listed last, so in order to understand the sequence, you’ll need to start at the bottom of the list and work your way backwards to the top. Or we can reduce left-to-right as you normally would, instead of right-to-left: This is important because sometimes if you compose backwards, you get a different result: Redux uses reducer functions to manage application state. A Redux-style reducer takes the current state and an action object and returns the new state: Redux has some reducer rules you need to keep in mind: Let’s rewrite our summing reducer as a Redux-style reducer that reduces over action objects: That makes unit testing Redux-style reducers a breeze. You should be starting to see that reduce is an incredibly useful and versatile abstraction. It’s definitely a little trickier to understand than map or filter, but it is an essential tool in your functional programming utility belt — one you can use to make a lot of other great tools. Next: Functors & Categories > Want to learn more about functional programming in JavaScript? He spends most of his time in the San Francisco Bay Area with the most beautiful woman in the world. Make some magic. #JavaScript JavaScript, software leadership, software development, and related technologies.