You can walk through the finite state machine diagram to see what kinds of strings the machine will produce, or you can feed it a given input string and verify whether or not there exists a set of transitions you can take to make the string (ending in an accepting state). Deterministic Finite Automata \(Q\) = a finite set of states \(\Sigma\) = a finite, nonempty input alphabet \(\delta\) = a series of transition functions \(q_0\) = the starting state \(F\) = the set of accepting states There must be exactly one transition function for every input symbol in \(\Sigma\) from each state. \(\Sigma\ = \{0,1\}\) The following table describes \(\delta\): \(q_0 = s_1\) \(F= {s_1}\) What string cannot be generated by the finite state machine below? Here is a DFA diagram that describes a few simple moves that a character in a video game can do: stand, run, and jump. The buttons that a player can use to control this particular character are "Up," "A," or the player can press no button. Nondeterministic Finite Automata \(Q\) = a finite set of states \(\Sigma\) = a finite, nonempty input alphabet \(\delta\) = a series of transition functions \(q_0\) = the starting state \(F\) = the set of accepting states An NDFA accepts a string \(x\) if there exists a path that is compatible with that string that ends in an accept state. NDFAs can be represented by diagrams of this form: The NDFA above recognizes strings that end in “10” and strings that end in “01.” State \(a\) is the start state, and from there, we can create a string with however many 1’s and 0’s in any order, and then transfer to state \(b\) or state \(e\), or we can immediately transfer to state \(b\) or state \(e\). In any case, the NDFA will only accept a string that reaches state \(d\) or state \(g\). In order to reach state \(d\) or state \(g\), the string must end with a “01” (for state \(d\)) or a “10” (for state \(g\)). For example, the following strings are all recognized by this NDFA. Which string cannot be generated by the finite state machine below? One might think that NDFAs can solve problems that DFAs cannot, but NDFAs are just as powerful as DFAs. However, a DFA will require many more states and transitions than an NDFA would take to solve the same problem. To see this, examine the example in the proof below. Proof Sketch NDFAs are equivalent to DFAs To convert a DFA into an NDFA, just define an NDFA that has all the same states, accept states, transitions, and alphabet symbols as the DFA. Essentially, the NDFA “ignores” its nondeterminism because it does not use null transitions and has exactly one transition per symbol in each state. DFAs are equivalent to NDFAs If an NDFA uses \(n\) states, a DFA would require up to \(2^n\) states in order to solve the same problem. To translate an NDFA into a DFA, use powerset construction. For example, if an NDFA has 3 states, the corresponding DFA would have the following state set: \(\{\emptyset, \{a\},\{b\},\{c\},\{a,b\},\{a,c\},\{b,c\},\{a,b,c\}\}\). Each element in the state set represents a state in the DFA. We can determine the transition functions between these states for each element of the set. For example, in the DFA, state \(\{a\}\) goes to \(\{a,b\}\) on input 0 since in the NDFA above, state \(\{a\}\) goes into both state \(a\) and state \(b\). This process is repeated for the remaining states in the set of the DFA. Since DFAs are equivalent to NDFAs, it follows that a language is regular if and only if it is recognized by an NDFA. Problem Loading... Note Loading... Set Loading...