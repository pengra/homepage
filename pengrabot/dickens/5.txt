GitHub is home to over 31 million developers working together to host and review code, manage projects, and build software together. Use Git or checkout with SVN using the web URL. Go back Go back Go back Go back Scryer Prolog aims to become to ISO Prolog what GHC is to Haskell: an open source industrial strength production environment that is also a testbed for bleeding edge research in logic and constraint programming, which is itself written in a high-level language. Phase 1 has been completed in that Scryer Prolog implements in some form all of the WAM book, including lists, cuts, Debray allocation, first argument indexing, last call optimization and conjunctive queries. Extend Scryer Prolog to include the following, among other features: Use the WAM code produced by the completed code generator to get JIT-compiled and -executed Prolog programs. The question of how to get assembly from WAM code is something I'm still considering. There are no current plans to implement any of these, but they might be nice to have in the future. They'd make a good project for anyone wanting to contribute code to Scryer Prolog. Implement the global analysis techniques described in Peter van Roy's thesis, "Can Logic Programming Execute as Fast as Imperative Programming?" Add unum representation and arithmetic, using either an existing unum implementation or an ad hoc one. Unums are described in Gustafson's book "The End of Error." Add support for shift/reset delimited continuations, see "Delimited Continuations for Prolog." Add concurrent tables to manage shared references to atoms and strings. Add optional SLG resolution for fast memoization of predicates. Add some form of JIT predicate indexing. If you'd like to disable readline (and the need for linking to it), install with the line Note on compatibility: Scryer Prolog should work on Linux, Mac OS X, and BSD variants on which Rust runs. Windows support hinges on readline and Termion being fully functional in that environment, which to my knowledge is not currently the case. The following predicates are built-in to Scryer. To enter a multi-clause predicate, the directive "[user]" is used. For example, Queries are issued as Wildcards work as well: and so do conjunctive queries: To clear the database, type To quit scryer-prolog, type Scryper supports dynamic operators. Using the built-in arithmetic operators with the usual precedences, Scryer has two specialized, non-ISO builtin predicates for handling so-called "partial strings". Partial strings imitate difference lists of characters, but are much more space efficient. This efficiency comes at the cost of full generality -- you cannot unify the tail variables of two distinct partial strings, because their buffers will always be distinct. ?- partial_string("abc", X), X = [a, b, c | Y], is_partial_string(X), is_partial_string(Y). X = [a, b, c, d, e, f], Y = [d, e, f]. At the time of this writing, several control and list processing operators and predicates are hidden in their own modules that have not been exported to the toplevel. To export them, write The [user] prompt can also be used to define modules inline at the REPL: