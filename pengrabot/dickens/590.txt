ReactJS and React Native are the new technologies for web and mobile development introduced by Facebook. The project was started by Jordan Walke, a Facebook software engineer, in 2011. To simplify the development process and foster a more comfortable user experience, he decided to create a library that would allow for building a web interface with JavaScript. In this article, we’ll address why React was created and the advantages and disadvantages of using React technologies. You can navigate to the section that intrigues you the most using links below: What is React Pros of ReactJS Cons of ReactJS ReactJS and React Native Pros of React Native Cons of React Native React App Examples Prior to developing ReactJS, Facebook was confronted with a major user experience task – building a dynamic UI with high performance. For instance, the engineers wanted to make news feed updates happen simultaneously with people using chat. To achieve that, Facebook had to optimize the development process itself and Jordan Walke decided to do it with JavaScript. He proposed putting XHP, the Facebook markup syntax, into the JS coordinate system. The idea seemed impossible, but in 2011 his team released the ReactJS library on the basis of JavaScript and XHP symbiosis. Then Facebook realized that ReactJS was working faster than any other implementation of its kind. How does React Native work? React Native combines native application development with JavaScript UI development. While computationally heavy features can be implemented with native modules for iOS and Android, the rest of the code can be written with JavaScript and shared across platforms. Unlike PhoneGap and Cordova cross-platform tools, React Native doesn’t use WebView, a mobile engine that wraps code. Instead, it provides access to native mobile controllers which allows for achieving native look and feel to apps. So, let’s take a closer look at ReactJS’ pros and cons as the main product. Then we’ll explore how React Native is different and which benefits and drawbacks it inherits from ReactJS. DOM (document object model) is a logical structure of documents in HTML, XHTML, or XML formats. Describing it in layman’s terms, it is a viewing agreement on data inputs and outputs, which has a tree form. Web browsers are using layout engines to transform or parse the representation HTML-syntax into document object model, which we can see in browsers. The main concern about traditional DOM construct is the way it processes changes, i.e., user inputs, queries, and so on. A server constantly checks the difference caused by these changes to give the necessary response. To respond properly, it also needs to update the DOM trees of the whole document, which is not ergonomically valid because DOM trees are fairly large today, containing thousands of elements. The team behind React managed to increase the speed of updates by using virtual DOM. Unlike other frameworks that work with the Real DOM, ReactJS uses its abstract copy – the Virtual DOM. It updates even minimalistic changes applied by the user, but doesn’t affect other parts of interface. That is also possible thanks to React components isolation, which we’ll get to in a minute, and a special data structure in the library. Real and Virtual DOMs This makes updates really quick, allowing for the building of a highly dynamic UI.  We can notice it writing in Facebook chat and seeing a simultaneously updating news feed. Moreover, in ReactJS, developers don’t have to bind DOM to functionality in the front-end because React elements are already connected to it. The approach enabled developers to work with UI-objects faster and use hot reloading (applying changes in a real-time mode).  Not only did it increase performance, it also made programming faster. Another advantage that Facebook introduced with React is the ability to reuse code components of a different level anytime, another meaningful time-saving effect. Think of designers. They constantly reuse the same assets. If they didn’t, they’d have to draw corporate logos, for instance, over and over again. It’s pretty obvious: Reusing is a design efficiency.  In programming, this process is a bit more difficult. System upgrades often turn into a headache as every change can affect the work of other components in the system. Most complex view-model systems of JS-representation have a significant but understandable disadvantage – the structure of data flow. In the view-model system, child elements may affect the parent if changed. Facebook removed these issues in React JS, making it just the view system. Instead of using explicit data binding, ReactJS uses one direction – downward – data flow. In such a structure, child elements cannot affect parent data. To change an object, all a developer needs to do is modify its state and apply updates. Correspondingly, only allowed components will be upgraded. Redux simplifies storing and managing component states in large applications with many dynamic elements where it becomes increasingly difficult. Redux stores application state in a single object and allows every component to access application state without dealing with child components or using callbacks. For instance, when you have two components that share the same state (like detailed and general views on the image below) and stand apart in the tree, without Redux, data has to be passed through multiple intermediary components with all the problems that go with it. The master and detail interfaces share the same data but the pass to the nearest ancestor of these two components may be high up in the tree Redux provides a centralized data store object to allow these components directly access it. This disadvantage are aptly described by developers Michael Jackson and Ryan Florence on Modern Web: “In case you didn’t notice we’re driving a car here with two flat tires, the hood just flew up in front of the windshield, and we have no clue what’s going on anymore!” The environment constantly changes, and developers must regularly relearn the new ways of doing things. Everything is evolving, and some developers are not comfortable with keeping up with such a pace. The problem with documentation traces back to constant releases of new tools. Different and new libraries like Redux and Reflux are promising to accelerate the work of a library or improve the entire React ecosystem. At the end, developers struggle with integrating these tools with ReactJS. Some members of the community think that React technologies are updating and accelerating so fast that there is no time to write proper instruction. To solve this, developers write their own documentation for specific tools used by them in current projects. All technical differences between them are caused by platform aims. Besides, React Native leverages and combines the main advantages of JavaScript and ReactJS. Due to the prevalence of JS code, engineers can work faster and more efficiently because they don’t have to restart a developed app after each update to see changes; they can simply refresh the viewing page. In some cases, after-launch updates can be done faster. For instance, Apple allows JavaScript-based changes of application behavior in real-time mode with no review cycle required. React Native renders some code components with native APIs, unlike other cross-platform frameworks such as PhoneGap, which render code via WebView, a mobile engine. While the WebView approach greatly reduces performance, React Native communicates with targeted components for iOS or Android and renders code to native APIs directly and independently. Doing that, React uses a separate thread from UI, which also increases the performance score. WebView Rendering vs React Native Rendering On top of that, React Native provides simple debugging and error messaging tools. For instance, similar to web-programming, specialists can use Chrome or Safari developer tools, both of which they’re usually familiar with. React Native uses ReactJS as the JavaScript library, so it has all its advantages.  To create a React Native app across platforms, developers don’t need to know the language of the native platform.  They must only be proficient in JavaScript and familiar with the React syntax. But, as mentioned, they can easily add native components to code as well. Unfortunately, React Native inherits the main ReactJS disadvantage. The community is young so the available documentation is poor, especially for integration with additional tools. We’ve discussed the native modules in the pros section. They definitely bring flexibility to the framework by filling the missing performance links. If you need to handle computationally heavy operations, you can inject native modules and achieve a truly native feel to your app. However, to some extent, it could negate the point of cross-platform development as you still need some native engineers (Objective-C, Java, or both) in reserve. So maybe you don’t need React Native to build the next mobile Photoshop. But, if you aren’t aiming at brute-force demanding tasks, JS expertise is enough. That said, React Native has a number of native modules for iOS and Android out-of-the-box, but the number of third-party components is still limited. And we can’t know for sure that community-built modules will be supported by the next releases of the framework. It remains a disadvantage, because React Native doesn’t offer a wide spectrum of possible features that developers may want to implement in their apps. React Native often drags its feet when iOS or Android updates their SDKs. React Native’s team should integrate a code library with new software. And despite the fact they work pretty fast, they cannot update every part of the APIs at once. That’s why the full synchronization between React Native and new SDKs often takes too long. Keep in mind that the tool is still in development and the path to smooth engineering experience won’t be easy. Companies who’ve already adopted ReactJS or React Native did so for different reasons. Here are the most notable adopters besides Facebook itself. This post is a part of our “The Good and the Bad” series. For more information about the pros and cons of the most popular technologies, see the other articles from the series: The Good and The Bad of Java Development The Good and The Bad of Xamarin Mobile Development The Good and the Bad of JavaScript Full Stack Development The Good and the Bad of Node.js Web App Development The Good and the Bad of Swift Programming Language The Good and the Bad of .NET Framework Programming The Good and the Bad of Selenium Test Automation Tool The Good and the Bad of Android App Development Thanks for the great post. Helped me understanding the difference! Thanks Stefan! Let us know if there’s any other technology you’d like us to clarify as well. Really very informative blog, What ever you written about React is true. It cleared many of my doubts. Thanks a lot. Thanks a lot, Ram!  Is there any other topic you’d like to be cleared out? Join the list of 9,587 subscribers and get the latest technology insights straight into your inbox.