 When the device is active it executes these operations at the rate of one operation per time unit (a  `step'). At the conclusion of each step, the finite control takes on a state from \(Q\ .\) The device is constructed so that it behaves according to a finite list of rules. These rules determine, from the current state of the finite control and the symbol contained in the cell under scan, the operation to be performed next and the state to enter at the end of the next operation execution. Consider \(x\) as a binary string. It is easy to see that the functions \(|x|\ ,\) \(f(x)= \bar x\ ,\) \(g( \bar x y)=x\ ,\) and \(h( \bar x y)=y\) are partial computable. Functions \(g\) and \(h\) are not total since the value for input \(1111\) is not defined. The function \(g'( \bar x y)\) defined as 1 if \(x = y\) and as 0 if \(x  \neq  y\) is a computable predicate. Consider \(x\) as an integer. The following functions are basic \(n\)-place total computable functions: the `successor' function \(\gamma^{(1)} (x) = x+1\ ,\) the `zero' function \(\zeta^{(n)} (x_1 , \ldots , x_n ) = 0\ ,\) and the  `projection' function \(\pi_m^{(n)} (x_1 , \ldots , x_n ) = x_m\) (\(1  \leq  m  \leq  n\)). The function \(\langle x, y\rangle  = \bar x y\) is a total computable one-to-one mapping from pairs of natural numbers into the natural numbers. We can easily extend this scheme to obtain a total computable one-to-one mapping from \(k\)-tuples of integers into the integers, for each fixed \(k\ .\) Define \(\langle n_1 , n_2 , \ldots ,n_k \rangle \) \(= \langle n_1 , \langle n_2 , \ldots , n_k \rangle \rangle\ .\) Another total recursive one-to-one mapping from \(k\)-tuples of integers into the integers is \(\langle n_1 , n_2 , \ldots ,n_k \rangle = \bar n_1   \ldots \bar n_{k-1}  \bar n_k\ .\) The class of algorithmically computable numerical functions (in the intuitive sense) coincides with the class of partial computable functions. Originally intended as a proposal to henceforth supply intuitive terms such as `computable' and `effective procedure' with a precise meaning, the Computability thesis has come into use as shorthand for a claim that from a given description of a procedure in terms of an informal set of instructions we can derive a formal one in terms of Turing machines. The only thing we have to do for every Turing machine is to encode the defining mapping \(T\) from \(Q \times A\) into \(S \times Q\ .\) Giving each element of \(Q \bigcup S\) a unique binary code requires \(s\) bits for each such element, with \(s  =  \lceil \log (|Q|+5) \rceil\ .\) Denote the encoding function by \(e\ .\) Then the quadruple \((p,0,B,q)\) is encoded as \(e(p)e(0)e(B)e(q)\ .\) If the number of rules is \(r\ ,\) then \(r \leq 3|Q|\ .\) We agree to consider the state of the first rule as the start state. The entire list of quadruples, \[ T = ( p_1 ,t_1 ,s_1, q_1 ) , (p_2 , t_2 ,s_2 , q_2 ), \ldots , (p_r , t_r , s_r , q_r ), \] is encoded as \[ E(T) = \bar s \bar r e( p_1 ) e( t_1 ) e( s_1 ) e( q_1 ) \ldots e(p_r ) e( t_r ) e( s_r ) e ( q_r ) . \] Note that \(l(E(T))  \leq  4rs + 2 \log rs + 4\ .\) (Moreover, \(E\) is self-delimiting, which is convenient in situations in which we want to recognize the substring \(E(T)\) as prefix of a larger string.) We order the resulting binary strings lexicographically (according to increasing length). We assign an index, or Gödel number, \(n(T)\) to each Turing machine \(T\) by defining \(n(T)=i\) if \(E(T)\) is the \(i\)th element in the lexicographic order of Turing machine codes. This yields a sequence of Turing machines \(T_1 ,T_2 , \ldots \) that constitutes the effective enumeration. One can construct a Turing machine to decide whether a given binary string \(x\) encodes a Turing machine, by checking whether it can be decoded according to the scheme above, that the tuple elements belong to \(Q \times A \times S \times Q\ ,\) followed by a check whether any two different rules start with the same two elements. This observation enables us to construct `universal' Turing machines. We focus on a universal Turing machine \(U\) that uses the encoding above. It is not difficult, but tedious, to define a Turing machine in quadruple format that expects inputs of the format \(E(T)p\) and is undefined for inputs not of that form. The machine \(U\) starts to execute the successive operations of \(T\) using \(p\) as input and the description \(E(T)\) of \(T\) it has found so that \(U(E(T)p)=T(p)\) for every \(T\) and \(p\ .\) We omit the explicit construction of \(U\ .\) The following sets are computable: (i) the set of odd integers; (ii) the set of natural numbers; (iii) the empty set; (iv) the set of primes; (v) every finite set; (vi) every set with a finite complement. The following sets are computably enumerable: (i) every computable set; (ii) the set of indices \(i\) such that the range of \(\phi_i\) is nonempty; (iii) the set \(\{ x:\) a run of at least \(x\) consecutive 0's occurs in \(\pi  \}\ ,\) where \(\pi = 3.1415 \ldots .\) The equivalent statements hold for computable and computably enumerable sets of \(n\)-tuples. In his original proof, Gödel uses diagonalization to prove the incompleteness of any sufficiently rich logical theory \(T\) with a computably enumerable axiom system, such as Peano arithmetic. By his technique he exhibits for such a theory an explicit construction of an undecidable statement \(y\) that says of itself `I am unprovable in \(T\ .\)' The formulation in terms of computable function theory is due to A. Church and S.C. Kleene. Turing's idea was to give a formal meaning to the notion of `giving a proof.' Intuitively, a proof is a sort of computation where every step follows (and follows logically) from the previous one, starting from the input. To put everything as broad as possible, Turing analyses the notion of `computation' from an `input' to an `output' and uses this to give an alternative proof of Gödel's theorem. The notion of computable functions can be extended from integer functions to real valued functions of rational arguments, and to weaker types of computability, using the framework explained above. We consider partial computable functions \(g( \langle \langle y, z  \rangle,k \rangle ) =  \langle p, q  \rangle\) and write \(g(y/z,k) = p/q\ ,\) with \(y,z,p,q,k\) nonnegative integers. The extension to negative arguments and values is straightforward. The interpretation is that \(g\) is a rational-valued function of a rational argument and a nonnegative integer argument. A function \(f\) is lower semicomputable iff the set \(\{ (x, r): r  \leq  f(x), \; r \;\; {\rm rational} \}\) is computably enumerable. Therefore, a lower semicomputable function is `computably enumerable from below,' and an upper semicomputable function is `computably enumerable from above.' An example of a  lower semicomputable function that is not computable. Let \(K = \{ x: \phi_x (x) <  \infty \}\) be the diagonal halting set. Define \(f(x) = 1\) if \(x  \in  K\ ,\) and \(f(x) = 0\) otherwise. We first show that \(f(x)\) is lower semicomputable. Define \(g(x, k) = 1\) if the Turing machine computing \(\phi_x\) halts in at most \(k\) steps on input \(x\ ,\) and \(g(x, k) = 0\) otherwise. Obviously, \(g\) is a rational-valued computable function. Moreover, for all \(x\) and \(k\) we have \(g(x, k + 1)  \geq  g(x, k)\ ,\) and \(\lim_{{k} \to \infty} g(x, k) = f(x)\ .\) Hence, \(f\) is lower semicomputable. However, if \(f(x)\) were computable, then the set \(\{ x: f(x) = 1 \} \ ,\) that is, the diagonal halting set \(K\ ,\) would be computable. But we have seen above that it is not. Theoretically, every  intuitively computable (effectively calculable) function is computable by a personal computer or by a Turing machine. But a computation that takes \(2^n\) steps on an input of length \(n\) would not be regarded as practical or feasible. No computer would ever finish such a computation in the lifetime of the universe even with \(n\) merely \(1000\ .\) For example, if we have \(10^9\) processors each taking \(10^9\) steps/second, then we can execute \(3.1 \times 10^{25} < 2^{100}\) steps/year. Computational complexity theory tries to identify problems that are feasibly computable. For convenience, we often give the Turing machine in the figure above a few more work tapes and designate one tape as a read-only input tape. Thus, each transition rule will be of the form \((p,{\bar s},a,q)\ ,\) where \(\bar s\) contains the scanned symbols on all the tapes, and \(p,a,q\) are as above, except that an operation now involves moving maybe more than one head. of languages accepted by multitape deterministic Turing machines in time \(O(t(n))\ ;\) nondeterministic Turing machines in time \(O(t(n))\ ;\) deterministic Turing machines in \(O(s(n))\) space; nondeterministic Turing machines in \(O(s(n))\) space. With \(c\) running through the natural numbers: Languages in P, that is, languages acceptable in polynomial time, are considered feasibly computable. The nondeterministic version for PSPACE turns out to be identical to PSPACE by Savitch's Theorem (due to W.J. Savitch in 1970) which states that \({\rm NSPACE}[s(n)]={\rm DSPACE}[(s(n))^2]\ .\) The following relationships hold trivially, \(: {\rm P} \subseteq {\rm NP} \subseteq {\rm PSPACE}. \) It is one of the most fundamental open questions in computer science and mathematics to prove whether either of the above inclusions is proper. Research in computational complexity theory focuses on these questions. In order to solve these problems, one can identify the hardest problems in NP or PSPACE. "NP is the set of problems for which it is easy to show (give a certificate) that the answer is `yes,' and P is the set of `yes/no' problems for which it is easy to find the answer. The technical sense of `easy' is `doable by a deterministic Turing machine in polynomial time.' The `P versus NP' question can be understood as whether problems for which it is easy to certify the answer are the same problems for which it is easy to find the answer. The relevance is this: Normally, we do not ask questions unless we can recognize easily in a certain sense when we have been handed the correct answer. We are not normally interested in questions for which it would take a lifetime of work to check whether you got the answer you wanted. NP is about those questions that we are likely to want answers to." This excellent explanation was given by one of the inventors of the notions P and NP, J.E. Edmonds in an interview in FAUW Forum, University of Waterloo, January 1993. This problem was the first natural problem shown to be NP-complete. Many practical issues seem to depend on fast solutions to this problem. Given a Boolean formula, a nondeterministic Turing machine can guess a correct truth assignment, and verify it. This takes only linear time. However, if we have to deterministically search for a satisfying truth assignment, there are \(2^n\) Boolean vectors to test.