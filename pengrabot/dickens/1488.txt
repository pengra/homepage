A comprehensive tutorial on cross-site scripting Cross-site scripting (XSS) is a code injection attack that allows an attacker to execute malicious JavaScript in another user's browser. The attacker does not directly target his victim. Instead, he exploits a vulnerability in a website that the victim visits, in order to get the website to deliver the malicious JavaScript for him. To the victim's browser, the malicious JavaScript appears to be a legitimate part of the website, and the website has thus acted as an unintentional accomplice to the attacker. The only way for the attacker to run his malicious JavaScript in the victim's browser is to inject it into one of the pages that the victim downloads from the website. This can happen if the website directly includes user input in its pages, because the attacker can then insert a string that will be treated as code by the victim's browser. In the example below, a simple server-side script is used to display the latest comment on a website: At first, the ability to execute JavaScript in the victim's browser might not seem particularly malicious. After all, JavaScript runs in a very restricted environment that has extremely limited access to the user's files and operating system. In fact, you could open your browser's JavaScript console right now and execute any JavaScript you want, and you would be very unlikely to cause any damage to your computer. However, the possibility of JavaScript being malicious becomes more clear when you consider the following facts: JavaScript has access to some of the user's sensitive information, such as cookies. JavaScript can make arbitrary modifications to the HTML of the current page by using DOM manipulation methods. These facts combined can cause very serious security breaches, as we will explain next. Among many other things, the ability to execute arbitrary JavaScript in another user's browser allows an attacker to perform the following types of attacks: Although these attacks differ significantly, they all have one crucial similarity: because the attacker has injected code into a page served by the website, the malicious JavaScript is executed in the context of that website. This means that it is treated like any other script from that website: it has access to the victim's data for that website (such as cookies) and the host name shown in the URL bar will be that of the website. For all intents and purposes, the script is considered a legitimate part of the website, allowing it to do anything that the actual website can. This fact highlights a key issue: If an attacker can use your website to execute arbitrary JavaScript in another user's browser, the security of your website and its users has been compromised. In this example, we will assume that the attacker's ultimate goal is to steal the victim's cookies by exploiting an XSS vulnerability in the website. This can be done by having the victim's browser parse the following HTML code: This script navigates the user's browser to a different URL, triggering an HTTP request to the attacker's server. The URL includes the victim's cookies as a query parameter, which the attacker can extract from the request when it arrives to his server. Once the attacker has acquired the cookies, he can use them to impersonate the victim and launch further attacks. The diagram below illustrates how this example attack can be performed by an attacker: The attacker uses one of the website's forms to insert a malicious string into the website's database. The victim requests a page from the website. The website includes the malicious string from the database in the response and sends it to the victim. The victim's browser executes the malicious script inside the response, sending the victim's cookies to the attacker's server. While the goal of an XSS attack is always to execute malicious JavaScript in the victim's browser, there are few fundamentally different ways of achieving that goal. XSS attacks are often divided into three types: The previous example illustrated a persistent XSS attack. We will now describe the other two types of XSS attacks: reflected XSS and DOM-based XSS. In a reflected XSS attack, the malicious string is part of the victim's request to the website. The website then includes this malicious string in the response sent back to the user. The diagram below illustrates this scenario: The attacker crafts a URL containing a malicious string and sends it to the victim. The victim is tricked by the attacker into requesting the URL from the website. The website includes the malicious string from the URL in the response. The victim's browser executes the malicious script inside the response, sending the victim's cookies to the attacker's server. At first, reflected XSS might seem harmless because it requires the victim himself to actually send a request containing a malicious string. Since nobody would willingly attack himself, there seems to be no way of actually performing the attack. As it turns out, there are at least two common ways of causing a victim to launch a reflected XSS attack against himself: If the user targets a specific individual, the attacker can send the malicious URL to the victim (using e-mail or instant messaging, for example) and trick him into visiting it. If the user targets a large group of people, the attacker can publish a link to the malicious URL (on his own website or on a social network, for example) and wait for visitors to click it. These two methods are similar, and both can be more successful with the use of a URL shortening service, which masks the malicious string from users who might otherwise identify it. DOM-based XSS is a variant of both persistent and reflected XSS. In a DOM-based XSS attack, the malicious string is not actually parsed by the victim's browser until the website's legitimate JavaScript is executed. The diagram below illustrates this scenario for a reflected XSS attack: The attacker crafts a URL containing a malicious string and sends it to the victim. The victim is tricked by the attacker into requesting the URL from the website. The website receives the request, but does not include the malicious string in the response. The victim's browser executes the legitimate script inside the response, causing the malicious script to be inserted into the page. The victim's browser executes the malicious script inserted into the page, sending the victim's cookies to the attacker's server. In the previous examples of persistent and reflected XSS attacks, the server inserts the malicious script into the page, which is then sent in a response to the victim. When the victim's browser receives the response, it assumes the malicious script to be part of the page's legitimate content and automatically executes it during page load as with any other script. The difference is subtle but important: In traditional XSS, the malicious JavaScript is executed when the page is loaded, as part of the HTML sent by the server. In DOM-based XSS, the malicious JavaScript is executed at some point after the page has loaded, as a result of the page's legitimate JavaScript treating user input in an unsafe way. In the previous example, JavaScript was not necessary; the server could have generated all the HTML by itself. If the server-side code were free of vulnerabilities, the website would then be safe from XSS. However, as web applications become more advanced, an increasing amount of HTML is generated by JavaScript on the client-side rather than by the server. Any time content needs to be changed without refreshing the entire page, the update must be performed using JavaScript. Most notably, this is the case when a page is updated after an AJAX request. This means that XSS vulnerabilities can be present not only in your website's server-side code, but also in your website's client-side JavaScript code. Consequently, even with completely secure server-side code, the client-side code might still unsafely include user input in a DOM update after the page has loaded. If this happens, the client-side code has enabled an XSS attack through no fault of the server-side code. This situation is not limited to fragment identifiers. Other user input that is invisible to the server includes new HTML5 features like LocalStorage and IndexedDB. Recall that an XSS attack is a type of code injection: user input is mistakenly interpreted as malicious program code. In order to prevent this type of code injection, secure input handling is needed. For a web developer, there are two fundamentally different ways of performing secure input handling: While these are fundamentally different methods of preventing XSS, they share several common features that are important to understand when using either of them: Secure input handling needs to be performed differently depending on where in a page the user input is inserted. Secure input handling can be performed either when your website receives the input (inbound) or right before your website inserts the input into a page (outbound). Secure input handling can be performed either on the client-side or on the server-side, both of which are needed under different circumstances. Before explaining in detail how encoding and validation work, we will describe each of these points. There are many contexts in a web page where user input might be inserted. For each of these, specific rules must be followed so that the user input cannot break out of its context and be interpreted as malicious code. Below are the most common contexts: In all of the contexts described, an XSS vulnerability would arise if user input were inserted before first being encoded or validated. An attacker would then be able to inject malicious code by simply inserting the closing delimiter for that context and following it with the malicious code. For example, if at some point a website inserts user input directly into an HTML attribute, an attacker would be able to inject a malicious script by beginning his input with a quotation mark, as shown below: This could be prevented by simply removing all quotation marks in the user input, and everything would be fineâbut only in this context. If the same input were inserted into another context, the closing delimiter would be different and injection would become possible. For this reason, secure input handling always needs to be tailored to the context where the user input will be inserted. Instinctively, it might seem that XSS can be prevented by encoding or validating all user input as soon as your website receives it. This way, any malicious strings should already have been neutralized whenever they are included in a page, and the scripts generating HTML will not have to concern themselves with secure input handling. Instead, outbound input handling should be your primary line of defense against XSS, because it can take into account the specific context that user input will be inserted into. That being said, inbound validation can still be used to add a secondary layer of protection, as we will describe later. In most modern web applications, user input is handled by both server-side code and client-side code. In order to protect against all types of XSS, secure input handling must be performed in both the server-side code and the client-side code. In order to protect against traditional XSS, secure input handling must be performed in server-side code. This is done using any language supported by the server. Now that we have explained why context matters, why the distinction between inbound and outbound input handling is important, and why secure input handling needs to be performed in both client-side code and server-side code, we will go on to explain how the two types of secure input handling (encoding and validation) are actually performed. The following pseudocode is an example of how user input could be encoded using HTML escaping and then inserted into a page by a server-side script: Because all characters with special meaning have been escaped, the browser will not parse any part of the user input as HTML. When performing encoding in your client-side code, the language used is always JavaScript, which has built-in functions that encode data for different contexts. When performing encoding in your server-side code, you rely on the functions available in your server-side language or framework. Due to the large number of languages and frameworks available, this tutorial will not cover the details of encoding in any specific server-side language or framework. However, familiarity with the encoding functions used on the client-side in JavaScript is useful when writing server-side code as well. When encoding user input on the client-side using JavaScript, there are several built-in methods and properties that automatically encode all data in a context-aware manner: The last context mentioned above (JavaScript values) is not included in this list, because JavaScript provides no built-in way of encoding data to be included in JavaScript source code. Even with encoding, it will be possible to input malicious strings into some contexts. A notable example of this is when user input is used to provide URLs, such as in the example below: Encoding is also an inadequate solution when you actually want the user to define part of a page's code. An example is a user profile page where the user can define custom HTML. If this custom HTML were encoded, the profile page could consist only of plain text. In situations like these, encoding has to be complemented with validation, which we will describe next. There are two main characteristics of validation that differ between implementations: User input can be classified using either blacklisting or whitelisting. User input identified as malicious can either be rejected or sanitised. However, blacklisting has two major drawbacks: Because of these drawbacks, blacklisting as a classification strategy is strongly discouraged. Whitelisting is usually a much safer approach, as we will describe next. Compared to blacklisting, there are two major benefits of whitelisting: When input has been marked as invalid, one of two actions can be taken: The input is simply rejected, preventing it from being used elsewhere in the website. All invalid parts of the input are removed, and the remaining input is used normally by the website. Of these two, rejection is the simplest approach to implement. That being said, sanitisation can be more useful since it allows a broader range of input from the user. For example, if a user submits a credit card number, a sanitisation routine that removes all non-digit characters would prevent code injection as well as allowing the user to enter the number either with or without hyphens. Encoding should be your first line of defense against XSS, because its very purpose is to neutralize data so that it cannot be interpreted as code. In some cases, encoding needs to be complemented with validation, as explained earlier. This encoding and validation should be outbound, because only when the input is included in a page do you know which context to encode and validate for. If these two lines of defense are used consistently, your website will be protected from XSS attacks. However, due to the complexity of creating and maintaining an entire website, achieving full protection using only secure input handling can be difficult. As a third line of defense, you should also make use of Content Security Policy (CSP), which we will describe next. The disadvantage of protecting against XSS by using only secure input handling is that even a single lapse of security can compromise your website. A recent web standard called Content Security Policy (CSP) can mitigate this risk. CSP can be used to enforce the following rules: External resources can only be loaded from a set of clearly defined trusted sources. Inline JavaScript and CSS will not be evaluated. In the following example, an attacker has succeeded in injecting malicious code into a page: Even if the attacker had injected the script code inline rather than linking to an external file, a properly defined CSP policy disallowing inline JavaScript would also have prevented the vulnerability from causing any harm. Since the security policy is sent with every HTTP response, it is possible for a server to set its policy on a page-by-page basis. The same policy can be applied to an entire website by providing the same CSP header in every response. The example headers in this section use newlines and indentation for clarity; this should not be present in an actual header. The syntax of a CSP header is as follows: This syntax is made up of two elements: For every directive, the given source expressions define which sources can be used to download resources of the respective type. The directives that can be used in a CSP header are as follows: The syntax of a source expression is as follows: In addition to the syntax above, a source expression can alternatively be one of four keywords with special meaning (quotes included): Allows no resources. Allows resources from the host that served the page. In this example policy, the page is subject to the following restrictions: Audio and video files cannot be downloaded from anywhere. Image files can be downloaded from any host. XSS is a code injection attack made possible through insecure handling of user input. A successful XSS attack allows an attacker to execute malicious JavaScript in a victim's browser. A successful XSS attack compromises the security of both the website and its users. There are three major types of XSS attacks: Persistent XSS, where the malicious input originates from the website's database. Reflected XSS, where the malicious input originates from the victim's request. DOM-based XSS, where the vulnerability is in the client-side code rather than the server-side code. All of these attacks are performed in different ways but have the same effect if they succeed. The most important way of preventing XSS attacks is to perform secure input handling. Most of the time, encoding should be performed whenever user input is included in a page. In some cases, encoding has to be replaced by or complemented with validation. Secure input handling has to take into account which context of a page the user input is inserted into. To prevent all types of XSS attacks, secure input handling has to be performed in both client-side and server-side code. Content Security Policy provides an additional layer of defense for when secure input handling fails. It should be noted that there is overlap in the terminology currently used to describe XSS: a DOM-based XSS attack is also either persistent or reflected at the same time; it's not a separate type of attack. There is no widely accepted terminology that covers all types of XSS without overlap. Regardless of the terminology used to describe XSS, however, the most important thing to identify about any given attack is where the malicious input comes from and where the vulnerability is located.