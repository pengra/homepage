In JavaScript, the textual data is stored as strings. There is no separate type for a single character. Let’s recall the kinds of quotes. Strings can be enclosed within either single quotes, double quotes or backticks: Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, including function calls: Another advantage of using backticks is that they allow a string to span multiple lines: If we try to use single or double quotes in the same way, there will be an error: Single and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile. For example, these two lines describe the same: There are other, less common “special” characters as well. Here’s the list: Examples with unicode: We would also use it if we want to insert a quote into the string. For instance: Of course, that refers only to the quotes that are same as the enclosing ones. So, as a more elegant solution, we could switch to double quotes or backticks instead: Strings can’t be changed in JavaScript. It is impossible to change a character. Let’s try it to show that it doesn’t work: For instance: In the following sections we’ll see more examples of this. Or, if we want a single character lowercased: There are multiple ways to look for a substring within a string. For instance: The optional second parameter allows us to search starting from the given position. The same algorithm can be layed out shorter: It would list the occurrences in the reverse order. For instance: It is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it. It’s the right choice if we need to test for the match, but don’t need its position: For instance: For instance: The first argument may be negative, to count from the end: Let’s recap these methods to avoid any confusion: Although, there are some oddities. A lowercase letter is always greater than the uppercase: Letters with diacritical marks are “out of order”: To understand what happens, let’s review the internal representation of strings in JavaScript. See? Capital characters go first, then a few special ones, then lowercase characters. The “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages. The same-looking letter may be located differently in different alphabets. So, the browser needs to know the language to compare. It provides a special method to compare strings in different languages, following their rules. For instance: The section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical of hieroglyphs characters or other rare symbols. You can skip the section if you don’t plan to support them. Most symbols have a 2-byte code. Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation. But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol. So rare symbols are encoded with a pair of 2-byte characters called “a surrogate pair”. Note that surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language! But, for instance, getting a symbol can be tricky, because surrogate pairs are treated as two characters: Note that pieces of the surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage. In the case above: In many languages there are symbols that are composed of the base character with a mark above/under it. To support arbitrary compositions, UTF-16 allows us to use several unicode characters. The base character and one or many “mark” characters that “decorate” it. If we need an additional mark above the letter (or below it) – no problem, just add the necessary mark character. For example: This provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different unicode compositions. For instance: To solve this, there exists a “unicode normalization” algorithm that brings each string to the single “normal” form. There are several other helpful methods in strings: Strings also have methods for doing search/replace with regular expressions. But that topic deserves a separate chapter, so we’ll return to that later. Open a sandbox with tests. We can’t “replace” the first character, because strings in JavaScript are immutable. But we can make a new string based on the existing one, with the uppercased first character: There are two variants here: Here’s the 2nd variant: Open the solution with tests in a sandbox. The function must be case-insensitive: Open a sandbox with tests. To make the search case-insensitive, let’s bring the string to lower case and then search: Open the solution with tests in a sandbox. The result of the function should be the truncated (if needed) string. For instance: Open a sandbox with tests. Note that there is actually a single unicode character for an ellipsis. That’s not three dots. Open the solution with tests in a sandbox. The example: Open a sandbox with tests. Open the solution with tests in a sandbox.