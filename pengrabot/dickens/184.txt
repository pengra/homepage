What’s a good natural key? This is a very difficult question for most entities when you design your schema. In some rare cases, there seems to be an “obvious” candidate, such as a variety of ISO standards, including: Now, the presence or absence of such a surrogate key is usually not too relevant in every day work with this table. If you’re using an ORM, it will likely make no difference to client code. If you’re using SQL, it definitely doesn’t. You just never use that additional column. But in terms of performance, it might make a huge difference! Clustered index … is a primary key index that “clusters” data together, which belongs together. In other words: … where OLTP usage often profits from clustered indexes. Non clustered index … is a primary key index that resides “outside” of the table structure, which is a heap table. In other words: The benefit of this table layout is that all lookups are equally fast, regardless if you’re using a primary key lookup or a secondary key search. There’s always an additional, constant time heap table lookup. The algorithmic complexities are: OLAP usage definitely profits from heap tables. Defaults With the algorithmic complexities above, we can easily guess what I’m trying to hint at here. In the presence of a clustered index, we should avoid expensive secondary key searches when possible. Of course, these searches cannot always be avoided, but if we review the alternative design of these two tables: … we can see that if we’re using a clustered index here, the clustering will be made based on either: The surrogate key clustering is really useless, because we never use the table this way. The benchmark adds: Using InnoDB (clustered indexes) Using MyISAM (heap tables) In the case of the heap table, the additional surrogate key column did not have any significant effect. A sort of minor note. Dr. Codd defined a “surrogate key” is being created by the SQL engine and completely hidden from the users. Think about a hash column, rather than an index that you actually have to create. Interesting, thanks for the pointer. I was not aware of that. This is not how we use the term today, though, right? After all, we often want to reference a row by precisely that surrogate key value, also from external systems. For write-heavy tables clustered indices are generally worse though, right? As in more work needing to be done to reorder the indices (even physical location of rows on some databases?) after an insert? Indeed, would be interesting to benchmark that as well. I have never benchmarked the difference yet, will do in the near future What if you cluster on the composite key but still add a surrogate PK? Well, you could do that of course to prevent this issue. You could also add a few secondary indexes and make sure to make them covering. There are many solutions to the problem exposed here. In your case, though, the question still remains. What’s the point of this surrogate PK in the relationship table? What are you gaining from it? Fill in your details below or click an icon to log in: Connecting to %s Enter your email address to follow this blog and receive notifications of new posts by email. Join 1,847 other followers