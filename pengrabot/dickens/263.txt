Size visualization of Go executables using D3 Raphael âkenaâ Poss Contents Overview Background and motivation Building the visualization Method Extracting executable entries Decomposing Go symbols Decomposing C/C++ symbols Organizing the data as a tree Visualization using D3 Example visualization for a simple program Example program Transformation process Interactive visualization Initial impressions What's inside a CockroachDB executable binary? Visual exploration Analysis Comparison between CockroachDB versions Of size/performance trade-offs and use cases Other oddities Summary and Conclusion Copyright and licensing Note Here's a static screenshot of how the app illustrates the size of the compiled code, in this example for a group modules in CockroachDB: The reason why I built this was to help me discover and learn what makes Go executable programs larger than I would expect. Thanks to this tool, I made several discoveries about how Go builds executable files. AnD YoU wOnT BeLiEVe WhAt I fOuND InSiDE! (Read more below.) Today, the latest build is 123MB large, 88MB stripped. This is a 194% (resp. 225%) increase since CockroachDB v1.0 was released, a bit more than two years ago. What happened? This is especially puzzling given that: These questions alone made me curious. My goal was to find some clarity into 123MB of inscrutable executable data. I started without knowing exactly how to achieve that. So I went to search for âzoomable d3 tree mapâ on my favorite search engine and discovered that D3 has native supports for tree maps, provided some input data in a suitable format. All these examples worked using D3 hierarchical data sets loaded from CSV or JSON with a particular schema. entries compiled from Go. These look like this: The first column is the address, and is of no interest here. The second column is the size. The third column is the entry type, and of no interest here either. The last part is the symbol for the entry. This model accurately describes a large majority of symbols, and can be readily decomposed using a simple regular expression. However, we quickly come across exotic names that do not fit this model: For the examples above, my program produces the following: Size Path Name 13 1 48 go.itab.*byLiteral,sort.Interface 113 Close 10 func1 123 encode-fm 82 1 Again, looking at real-world binaries, we easily find many items that don't fit the simple model: For the examples above, my program produces the following: Size Path Name 8 ['$f64.'] c05eb8bf2d05ba25 100 71 NowNanos() 231 Sync() [clone .cold.88] 211 operator<<(long) Some difficulty arises from the fact that C++ symbols can contain an arbitrarily amount of nested template parameters or parentheses in types, and regular expressions cannot match recursively. My current implementation is thus restricted to only supports 6 levels of nesting. This appears to be insufficient to capture all symbols in my program of interest (where some symbols contain 10+ levels of nesting!) but I chose to exclude a few symbols to keep my regular expression simple(r). In my target analysis, the size of these excluded symbols is negligible anyway. Whereas the D3 visualization code really wants this: The reason why I separated the code into two programs is that the decomposition of symbols is rather expensive, and once I was satisfied with the decomposition I wanted the ability to iterate quickly on the tree transform without having to decompose over and over again. The original D3 tree map example as initially designed by Mike Bostok, and modified by Jahnichen Jacques and Guglielmo Celata operates thus: On top of this logic by the previous authors, I added the following: We'll use the following Go code: The program can be compiled as usual: I then use the following commands: The following HTML code is sufficient: Which renders as follows (ensure Javascript is enabled): Although this simple executable file appears to only contain Go symbols, it actually does contain C/C++ symbols too. However, their size is negligible and they initially appear as a mere line on the right side of the tree map. By clicking on that line, you may be able to zoom into them and obtain this: The small programm above contains 6 lines of source code and compiles to a 1.3MB binary. The breakdown of sizes is as follows: Package Size runtime 900K / 71% main 80K / 6.3% unicode 77K / 6.1% reflect 72K / 5.7% fmt 38K / 3.0% strconv 31K / 2.5% sync 10K / 0.8% internal 9K / 0.7% syscall 6K / 0.5% (others) (remainder) In addition to code compiled from source, 24K (1.9% of size) are compiler-generated type equality and hashing functions. These are accumulated in the box TYPEINFO in the tree map. The following becomes clear quickly: We'll come back to this below. Applying the tool on a recent CockroachDB build, one can find the following: By exploring this visualization, we discover: 71M of total entries; 8.4M (12% of size) in C/C++ entries, including 3M (4.3%) from RocksDB; 62M (88%) in Go entries, including: 32M (45%) compiled directly from CockroachDB source code or its dependencies; The visualization above was for a pre-release build of CockroachDB v19.1. For reference, here is the data for CockroachDB v1.0: This has: 32M of total entries; 2.5M (7.8%) in C/C++ entries, including 1.5M (4.7%) from RocksDB; 30M (92%) in Go entries, including: 16M (50%) compiled from CockroachDB sources and dependencies; Recalling the initial problem statement, CockroachDB increased about 140% in source code size between v1.0 and v19.1. Thanks to the visualization, we observe that the compiled code that directly originates from the CockroachDB sources increased from 16M to 32MB, which is about a 100% increase. // A LineTable is a data structure mapping program counters to line numbers. in Go 1.2, a decision was made to pre-expand the line table in the executable file into its final format suitable for direct use at run-time, without an additional decompression step. The change in design between Go pre-1.2 and go 1.2 is a classic trade-off between performance (time) and memory (space). When is this trade-off warranted? In that case, the Go 1.2 design is sound and warranted. This makes the Go 1.2 design â¦ not so advantageous. Year 2017 2019 2021 (projected) 2023 Total size 32M 71M 157M 350M CockroachDB code 16M (50%) 32M (45%) 64M (41%) 128M (37%) runtime.pclntab 7.3M (23%) 26M (36%) 85M (54%) 281M (80%) the Go compiler and linker always produce and keep the following entries, even when they are only used in functions elided by the linker because they are not used: interface ever mentioned in the source code. This accounts for about 1% of the CockroachDB 19.1 binary, and is predicted to increase with the introduction of more inter-component interfaces for testing in 19.2. This accounts for about 1.2% of the CockroachDB 19.1 binary, and is predicted to increase with the increasing use of code generation for optimizations inside CockroachDB 19.2. In my experience, this is specifically the inflection point for the ratio between source code size and compiled code size in a monomorphic C-like language: when targeting fixed-length instruction encodings and/or a memory-heavy calling convention, the size of the compiled code grows larger than the source code (excluding comments and whitespace). We can see this with both C on ARMv6 (no Thumb) or Go on x86(-64). When targeting variable-length instruction encodings and the calling convention suitably utilizes the more compact instructions, the size of the compiled code becomes smaller than the source code. We can see this with C on x86(-64) with a decent compiler, but, as examined here, not with Go. This object is automatically generated by the Go compiler to support the generation of textual stack traces at run-time, for example in error reports. This design choice was intended to lower the start-up time of programs, and contrasts with the previous design using compressed tablesâwhich is, incidentally, the industry standard for other C-like languages, even in contemporary compilers. This performance goal is not relevant to server software with long-running processes, like CockroachDB, and its incurred space cost is particularly inconvenient for large, feature-rich programs.