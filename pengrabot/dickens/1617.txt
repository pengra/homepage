The web framework for perfectionists with deadlines. To create a new instance of a model, just instantiate it like any other Python class: Note Add a classmethod on the model class: Add a method on a custom manager (usually preferred): Below is an example showing how to record the initial values of fields that are loaded from the database: If you delete a field from a model instance, accessing it again reloads the value from the database: Note that when deferred fields are accessed, the loading of the deferred field’s value happens through this method. Thus it is possible to customize the way deferred loading happens. The example below shows how one can reload all of the instance’s fields when a deferred field is reloaded: A helper method that returns a set containing the attribute names of all those fields that are currently deferred for this model. There are three steps involved in validating a model: This method should be used to provide custom model validation, and to modify attributes on your model if desired. For instance, you could use it to automatically provide a value for a field, or to do validation that requires access to more than a single field: The model save process also has some subtleties; see the sections below. If you assign auto-primary-key values manually, make sure not to use an already-existing primary-key value! If you create a new object with an explicit primary-key value that already exists in the database, Django will assume you’re changing the existing record rather than creating a new one. Explicitly specifying auto-primary-key values is mostly useful for bulk-saving objects, when you’re confident you won’t have primary-key collision. When you save an object, Django performs the following steps: Most fields don’t require data preparation. Simple data types, such as integers and strings, are ‘ready to write’ as a Python object. However, more complex data types often require some modification. It should be very rare that you’ll need to use these parameters. Django will almost always do the right thing and trying to override that will lead to errors that are difficult to track down. This feature is for advanced use only. Sometimes you’ll need to perform a simple arithmetic task on a field, such as incrementing or decrementing the current value. The obvious way to achieve this is to do something like: You can’t share pickles between versions Pickles of models are only valid for the version of Django that was used to generate them. If you generate a pickle using Django version N, there is no guarantee that pickle will be readable with Django version N+1. Pickles should not be used as part of a long-term archival strategy. A few object methods have special purposes. For example: For example: For example: For example: Warning You should avoid building the URL from unvalidated user input, in order to reduce possibilities of link or redirect poisoning: This template code is much better: Note For example: Note that in the case of identical date values, these methods will use the primary key as a tie-breaker. This guarantees that no records are skipped or duplicated. That also means you cannot use those methods on unsaved objects.