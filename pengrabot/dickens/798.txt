How to use it: If you have never used ES6 syntax before, donâ€™t let the example above intimidate you. Itâ€™s exactly the same as writing: Iâ€™ll use ES6 syntax for the rest of the examples, since itâ€™s more concise and leaves less room for errors. Instead of logging the sum, you could divide the sum by the length of the array before you return a final value. If you can use the reduce function to spit out an average then you can use it any way you want. The thing is, you donâ€™t always have to return a single value. You can reduce an array into a new array. For instance, lets reduce an array of amounts into another array where every amount is doubled. To do this we need to set the initial value for our accumulator to an empty array. Weâ€™ve created a new array where every amount is doubled. We could also filter out numbers we donâ€™t want to double by adding an if statement inside our reducer. For these examples, it would make more sense to use map or filter because they are simpler to use. The benefit of using reduce comes into play when you want to map and filter together and you have a lot of data to go over. If you chain map and filter together you are doing the work twice. You filter every single value and then you map the remaining values. With reduce you can filter and then map in a single pass. Use map and filter but when you start chaining lots of methods together you now know that it is faster to reduce the data instead. To tally items in an array our initial value must be an empty object, not an empty array like it was in the last example. Since we are going to be returning an object we can now store key-value pairs in the total. On our first pass, we want the name of the first key to be our current value and we want to give it a value of 1. This gives us an object with all the fruit as keys, each with a value of 1. We want the amount of each fruit to increase if they repeat. To do this, on our second loop we check if our total contain a key with the current fruit of the reducer. If it doesnâ€™t then we create it. If it does then we increment the amount by one. I rewrote the exact same logic in a more concise way up top. We can use reduce to flatten nested amounts into a single array. We set the initial value to an empty array and then concatenate the current value to the total. More often than not, information is nested in more complicated ways. For instance, lets say we just want all the colors in the data variable below. Weâ€™re going to step through each object and pull out the colours. We do this by pointing amount.c for each object in the array. We then use a forEach loop to push every value in the nested array into out total. An interesting aspect of the reduce method in JavaScript is that you can reduce over functions as well as numbers and strings. Letâ€™s say we have a collection of simple mathematical functions. these functions allow us to increment, decrement, double and halve an amount. For whatever reason, we need to increment, then double, then decrement an amount. You could write a function that takes an input, and returns (input + 1) * 2 -1. The problem is that we know we are going to need to increment the amount three times, then double it, then decrement it, and then halve it at some point in the future. We donâ€™t want to have to rewrite our function every time so we going to use reduce to create a pipeline. A pipeline is a term used for a list of functions that transform some initial value into a final value. Our pipeline will consist of our three functions in the order that we want to use them. Instead of reducing an array of values we reduce over our pipeline of functions. This works because we set the initial value as the amount we want to transform. Because the pipeline is an array, it can be easily modified. If we want to decrement something three times, then double it, decrement itÂ , and halve it then we just alter the pipeline. The reduce function stays exactly the same. If you donâ€™t pass in an initial value, reduce will assume the first item in your array is your initial value. This worked fine in the first few examples because we were adding up a list of numbers. If youâ€™re trying to tally up fruit, and you leave out the initial value then things get weird. Not entering an initial value is an easy mistake to make and one of the first things you should check when debugging. Another common mistake is to forget to return the total. You must return something for the reduce function to work. Always double check and make sure that youâ€™re actually returning the value you want. Tools, Tips & References And if you liked the article, click the ðŸ’š below so other people will see it on Medium. Stories worth reading about programming and technology from our open source community.