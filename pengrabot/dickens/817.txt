2012/05/27 For reliable multichannel web (mobile, tablet, desktop, etc) it is important to avoid or at least reduce the amount of JavaScript. There are of course some things that JavaScript is essential for, such as: Many sites use excessive JavaScript to behave as if they were a native app or for unnecessary "cool" features that are not cost effective. Â There are several disadvantages of doing this: If you pretend to be a native application, you are setting up the users expectations. Â Those expectations will not be met from a request response paradigm. Building a mobile / tablet site that looks and feels native means you are building a specific single channel site or at least a specific design for mobile / tablet. Why would you have separate designs / look-and-feel                         for a single channel unless there is a very strong business reason to offset the significant increase in cost? Design should reflect the product / company and not the platform they appear on and therefore should be homogeneous across all channels                         (mobile, tablet, desktop, etc). It is possible to use adaptive design to build once and use everywhere across all channels. (Note: this blog fits nicely into all screen sizes, try resizing your window).                         Adding too much complex JavaScript into a site makes it considerably harder to support multi channel and in most cases is not cost effective. JavaScript runs differently across different browsers and devices, in fact the mobile web is a hostile environment for JavaScript. Â For example even devices from the same manufacturer such as iPad and iPhone often behave quiet differently. Â This is due to timing                         differences between JavaScript execution, page reflow and DOM updates. Â Between operating systems the differences can be even bigger such as between iPhone and Android. How user interaction (i.e. events) is optimised is different on each browser. Â The problem is that there is only a single UI Thread (i.e. limited resources) that handles all screen updates and JavaScript execution.Â  Therefore to ensure that the                             browser does not lock up and stays responsive each browser takes a different approach to avoiding "unnecessary" work.Â  For example, when a user triggers an event (i.e. clicks a button) while JavaScript is already executing: For example Internet Explorer throttles JavaScript tasks triggered by user interaction so that it recognizes only two repeated events in a row and drops subsequent events. The questions to ask yourself are: The level of testing required is much higher with JavaScript. Â In a browser it is not possible to control the execution environment unlike with a Web Server due to the difference combinations of mobile hardware, operating system and browser versions.Â  Therefore the same functionality has to be tested across                         a wide range of devices.Â  Even if this is done, it is not possible to be confident you have covered all devices. Is there a reason to add extra complexity? It seems like too many sites have "cool" features that may look sexy the first time you see it but don't actually improve the user experience. These features are very expensive to build, support and maintain. I                         would recommend "if in doubt leave it out" and if you can't do without it try using A/B or Multivariate testing to show whether new features actually improve profit. Does the business realise by adding these cool features the site will take longer to                         build, cost more to support and will be more likely to have bugs? In addition in most cases these extra features reduce performance as they add extra page weight. In summary putting all the functionality into the Web Server or other middle tier components ensures you control of the execution environment.Â  This means complexity reduction, increase of reliability and reduction of testing and maintenance costs.Â  The only                     hurdle to overcome is to convince the designers to produce a design that is homogeneous across all channels and doesn't behave like a native application. It is of course possible to build a web application that behaves like aÂ native application. However, the question is not whether it is possible, but whether it is the sensible profitable thing to do. Ensure all features / User Stories work with and without JavaScript, for the following reasons: Ask why complexity is required in the browser? Does it warrant the product release being delayed, costing more to build, test and support? Is the correct trade-off being truly considered? Use A/B or Multivariate testing to demonstrate whether "cool" features have a long term impact on profitability. A general principle to follow for multichannel sites is don't try to compete with native applications and when in doubt, leave it out. - Alan Cooper James D Bloom Related Articles Java Code To Byte Code - Part One JVM Internals Easy API To Mock HTTP Endpoints Simplify Testing Vert.X Verticles & Modules Testing Web Pages In Process JS and CSS Minification With WRO4J Using PropertySource & Environment Reducing & Minifying Requests High Performance Mobile Websites Mobile Strategy Reduce JavaScript for Mobile Web Why Does Web Performance Matter? Mobile Web Best Practices How To Float Correctly James Bloom is an architect and technical lead with 13 years experience developing web based distributed enterprise systems in a wide range of industries.  He builds high performance adaptive web sites that are designed to run reliably across a wide range of devices.  He also focuses on high quality sustainable delivery through fast feedback loops in agile, continuous delivery, and a very high level of automated testing across a wide range of devices.  He builds solutions that maximise return-on-investment by analysing patterns of user behaviour in response to changes in design, performance and errors. Other Articles Why use Application Cache? How to use Application Cache Tips when using Application Cache Problems with Application Cache JavaScript and Application Cache Â© 2012 James D Bloom