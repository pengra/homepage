Here is the FOLDOC article on this... if there is any information from here that can be merged into the main article, do so: Finite State Machine <mathematics, algorithm, theory> (FSM or "Finite State Automaton", "transducer") An abstract machine consisting of a set of states (including the initial state), a set of input events, a set of output events, and a state transition function. The function takes the current state and an input event and returns the new set of output events and the next state. Some states may be designated as "terminal states". The state machine can also be viewed as a function which maps an ordered sequence of input events into a corresponding sequence of (sets of) output events. A deterministic FSM (DFA) is one where the next state is uniquely determinied by a single input event. The next state of a nondeterministic FSM (NFA) depends not only on the current input event, but also on an arbitrary number of subsequent input events. Until these subsequent events occur it is not possible to determine which state the machine is in. It is possible to automatically translate any nondeterministic FSM into a deterministic one which will produce the same output given the same input. Each state in the DFA represents the set of states the NFA might be in at a given time. In a probabilistic FSM [or stochastic FSM], there is a predetermined probability of each next state given the current state and input (compare Markov chain). The terms "acceptor" and "transducer" are used particularly in language theory where automata are often considered as abstract machines capable of recognising a language (certain sequences of input events). An acceptor has a single Boolean output and accepts or rejects the input sequence by outputting true or false respectively, whereas a transducer translates the input into a sequence of output events. FSMs are used in computability theory and in some practical applications such as regular expressions and digital logic design. See also state transition diagram, Turing Machine. [J.H. Conway, "regular algebra and finite machines", 1971, Eds Chapman & Hall]. [S.C. Kleene, "Representation of events in nerve nets and finite automata", 1956, Automata Studies. Princeton]. [Hopcroft & Ullman, 1979, "Introduction to automata theory, languages and computations", Addison-Wesley]. [M. Crochemore "tranducters and repetitions", Theoritical. Comp. Sc. 46, 1986]. Ideally I think it would be best to have a seperate page for tools so that we could add some more (there are tons of them out there), sort them in categories and give a short description (IMHO having just the names is almost totally useless, the names and a link is already better but still not good enough). I see at least three distinct categories (some programs would fall into more than one category but that's ok, I guess): I don't feel strong enough to write a good article about the hardware applications now. Therefore I just moved the old content from the Implementation section to the Hardware application section making just small corrections. My changes in the Implementation section are focused on the definition and software applications, so let me know if you have any comments... I replaced the new FSM logic by the old one, as it uses terms which are not mentioned/explained on the page: state generator, output generator etc. I wonder if this terms are correct in this context. Maybe some specific FSM modification was meant, but then I would write a new article, as this is not a classic FSM any more. For instance an FSM does not generate any states, but it is in a certain state and can change the state if certain (input) conditions are fulfilled. If I understand correctly the comment of Deco, you would like to have a parser example instead of the provided door open/close example. I had to think about my salesman friend: I'm sure he will get an idea of how an FSM works if I tell him that a door can be closed or open and that this are the states of the door FSM. Then I mention the two obvious possible transitions: open to close, close to open and my friend learned something within few minutes. And if he is more interested I add an engine to control the door, which can be controlled by commands "close" and "open" and the actions problem is also clear. A parser is an academic example which would cover only few aspects of FSM and is probably to abstract to my friend. However I agree that it might be useful to put both examples, as we know everybody has his own individual preferred way of learning and this shall be probably taken into account by articles in Wikipedia. I removed the changes done by 81.208.61.96 because the information was misleading. He wrote: The two most relevant things are incorrect: 2. mixed models are typically used in software most probably, but in hardware mainly Moore model is used. So to keep this article generic, we better state "mixed models are often used", not more. It presently says, for Mealy: "Output depends on input and state, i.e. the FSM uses only input actions." Confusing! Perhaps what is needed is a clarification of "Input Action"? I feel that there should be a separate article on Moore and Mealy, to explain in more detail about how they work, and how they differ from the others. Thanks for the responses! I already made my change though: I made it say: "execute the action dependant on present state and input conditions" There are two problems with it: 2. Moore machine uses only entry actions, but it does not mean that in each state an entry action must be present. Based on several comments and questions in the past, I found that the difference between Moore and Mealy as well as the sense and advantages of using a certain model are pretty confusing for many readers of the FSM article. Therefore I added a link to an external page, where a technical note about this topic accompanied by an executable example is presented. Maybe this is more helpful? This article seems to have a quite narrow focus in viewing finite state automata as machines with finite control state that react to events.  Certainly for some applications, that view is sufficient, but finite automata are one of the most fundamental structures to computer science, and have a huge array of applications (usually with some generalizations, e.g. Markov chains can be viewed as stochastic finite automata, different logics can be interpreted using finite state automata over finite and/or infinite strings, properties in abstract algebra and term rewrite systems can be solved using finite tree automata, etc...  At the same time, it is clear that a number of people have spent quite a bit of time on explaining finite automata in terms of these reactive state machines, and the explanation is those terms is quite good. Perhaps there should be two articles, one on finite automata, the other on finite state machines.  The finite automata article presents a high level overview of finite automata, how they are used, and why they are important.  The finite state machine article gives a concrete model of a finite automata, specifically the one presented in this article.  Before attempting to make such a large change, I thought I'd solicit feedback. Minsky (1967) spends about 20 pages giving us a definition of a "finite-state machine". It includes the following (italics in original): In this context the word "state" is derived as follows: And there really is no need for 'Mealy machines' anyway, because any 'Mealy' can be converted into a 'Moore' (cf Booth (1967), p. 960. Here he discusses this problem, that a 'Mealy' produces no output unless there's an input. He also notes that "a short time is allowed after the input symbol is applied before the output is observed", etc. This is bizarre. No input e.g. (0,0,0,0) produces no output (0,0,0,0) but the machine is in a particular state, call it "B". As soon as an input is applied i.e. (0,1,0,0) the machine goes to a new state, call it "D". During its brief time going from B to D it produces an output (0,0,1,1). This appears as a pulse during the transition.  If D is to sustain this pulse it must have a recirculating path back to itself i.e. (0,1,0,0) produces a recirculation back to D and maintains (0,0,1,1). Clearly, this is not trival stuff. There is a problem with starting line of article. Basically it states that actions are fundamental part of automata and than it proceeds with entry/exit/input/transition actions. This isn’t right. Actually it is completely wrong. Automata with actions, like more or mealy machines or workflows in general, are higher level abstractions of state automata. Actions are cool concept but they are convenience within automata; they do not present fundamental property of state machines. Fundamental property is transition table. Stating that automata have actions is plain wrong. This article also fails to mention that fundamental automat is DFA. It doesn’t state that fundamental property of automata is state transition table (that is states and graph they make). All automata can be presented as DFA, and if there is some *automata* which can’t be transformed to DFA than it isn’t automata. That’s why they are called state machines in the first place. This article doesn’t state that and it doesn’t make proper distinction between fundamental parts of automata and conveniences which we use to make them easier to handle. A finite state machine is an atomized model of a type of "computation": with discrete, finite and "static-between-moves" behaviors (see the section above for definitions of "state"). The canonical FSM model is nothing more than a single lookup table with a memory feeding back to the lookup table, inputs into the lookup table, and outputs from the lookup table. Whether the memory is clocked or not depends on what the designer is up to. Clocking helps eliminate evil behaviors such as "races" etc. Every single type of real and model FSM (e.g. decimal counters) can be redrawn to "look like" the canonical model. Such an atomized model will not have all these different kinds of input and output behaviors. To write an article within an encyclopaedia you shall compare multiple books and have experience in several different use cases, not only hardware design (based on your remarks, I assume you are a “hardware man”) Wikipedia should explain some basic concepts, and  direct by links to special cases or exotic derivations. The origin of a finite state machine comes from the Automata Theory, well known in some circles for over half a century, and the concept is presented in that way in the Wikipedia article. I find the references from this section which use message terminology much clearer and more consistent than this article. I'm suggesting use of 'message', 'input message' or 'output message' in place of 'input', 'output', 'condition', 'action' etc. This emphasizes the importance of time and sequence in the theory. For example, the distinction between Deterministic and Non-deterministic FSMs is quite incomprehensible in the article as it stands but can be clearly explained in message terms. A non-deterministic FSM is one in which the state may depend on more than one input message, so the state is indeterminate from the arrival of the first message to the arrival of the last. This also makes it easy to explain why a non-deterministic FSM can be converted to a deterministic one - intermediate states are added for all possible message sequences which provides the machine with a message memory and representations for the previously indeterminate states. In these terms, a recognizer receives a sequence of input messages each representing a single character. When the required sub-sequence has been recognized, it dispatches an output message signaling this fact. As far as I can see message terminology is generic and covers all FSM variants and usages so avoiding the confusion of multiple domain specific terms like 'string', 'input condition' and 'accepting state'. They are all correct.  It is an interesting question, and I hope it will be an interesting answer. There are three meanings for "state": The third meaning of state relates to the diagram; the first two to the machine. The confusion arises for two-part reason that each of the quantities of states are all in fixed relation, and so finite may refer to any of the three and infer the others. A person may have one concept on their mind, when they read or write such a hyper-hyphenate-able phrase—or not—only three will do to understand the answer. Each of the quantities of states are all in fixed relation because the quantity of state-positions in the diagram is related to  the quantity of state-points measured internal to the machine is related to  the quantity of values in the measurement range of each point. The world is plumb full of it. Just stick up your thumb.  Thank you for asking, for now I know.   The remaining is the edited phase-of-confusion I waded through. A Google search shows that the following universities say "finite-state machine": An object is something which has a state... the object paradigm is universal. I don't think there is a wiki page for an Infinite State Machine, so why does this page seem to be distinguishing itself from that page by insisting it is about a FINITE state machine? (In other words, the concept is STATE MACHINE, and the page should be as well.) Twice now, my edits had been reverted by those who honestly seem to believe this. They've seemed to had reverted this based upon the assumption that the other models of computations, Turing machines, especially, are a lot more powerful than Finite State Machines and are, therefore, can not be considered Finite State Machines in their own right. This is in spite of the fact that both pushdown automation and Turing machines uses state machines as the core of their logic. Pushdown automations and Turing machines are, in full effect, both finite state machines, those designed to manipulate a stack-based system and tape-based memory, respectively. Hello fellow Wikipedians, When you have finished reviewing my changes, you may follow the instructions on the template below to fix any issues with the URLs.